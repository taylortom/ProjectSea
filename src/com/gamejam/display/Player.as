package com.gamejam.display {	// Flash imports	import flash.geom.Point;	import flash.display.MovieClip;	import flash.display.Stage;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import com.gamejam.views.GameView;	import com.gamejam.managers.SoundManager;			/**	 * Player class - movement controlled by keyboard, stores values for temperature and movement	 * @author Kev Adsett	 */	public class Player extends MovieClip	{		//player states		private static var BIRTH : int = 0;		private static var FROZEN : int = 1;		private static var FREEZING2 : int = 2;		private static var FREEZING1 : int = 3;		private static var WATER : int = 4;		private static var BOILING1 : int = 5;		private static var BOILING2 : int = 6;		private static var BOILED : int = 7;				private var _state : int;				private var _movementDirection : int;		private var _moveable:Boolean = true;		private static var LEFT : int = -1;		private static var STILL : int = 0;		private static var RIGHT : int = 1;				private var xVel : Number = 0.0;		private var xPos : Number = 0.0;		private var maxVel : Number = 20.0;				private var health : int = 2;		private var maxHealth : int = 2;				private var temperature : int = 0;				public function Player() 		{			super();			_init();		}				private function _init():void 		{			//trace("Player::_init");						var _stage : Stage = GameView.getInstance().stage;			this._changeState();						_stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyboardDown);			_stage.addEventListener(KeyboardEvent.KEY_UP, onKeyboardUp);			this.addEventListener(Event.ENTER_FRAME, onEnterFrame);		}				private function onEnterFrame(e:Event):void 		{			if(this._moveable) _move();		}				private function onKeyboardDown(e:KeyboardEvent):void 		{			//trace("e.keyCode: " + e.keyCode);			if (e.keyCode == Keyboard.LEFT)			{				_movementDirection = LEFT;			}			else if (e.keyCode == Keyboard.RIGHT)			{				_movementDirection = RIGHT;			}		}				private function onKeyboardUp(e:KeyboardEvent):void 		{			_movementDirection = STILL;		}				public function kill():void		{			trace("Player.kill");						/*			1. Play death animation			2. (at the end of the animation) remove eventlisteners & destroy movieclip			3. Respawn at top of screen(?)			*/		}				public function increaseTemperature():void		{			temperature++;			this._changeState();		}				public function decreaseTemperature():void		{			temperature--;			this._changeState();		}				private function _changeState(): void		{			trace("_changeState()");						var sm:SoundManager = SoundManager.getInstance();						switch(temperature)			{				case -3: 					this.gotoAndPlay("frozen");					sm.playEffect(new Frozen());					break;				case -2:					this.gotoAndPlay("freezing2");					sm.playEffect(new Freeze());					break;				case -1:					this.gotoAndPlay("freezing1");					sm.playEffect(new Freeze());					break;				case 0:					this.gotoAndPlay("water");					sm.playEffect(new Droplet1());					break;				case 1:					this.gotoAndPlay("boiling1");					sm.playEffect(new Boil());					break;				case 2:					this.gotoAndPlay("boiling2");					sm.playEffect(new Boil());					break;				case 3:					this.gotoAndPlay("boiled");					sm.playEffect(new Boiled());					this.moveable = false;					GameView.getInstance().camera.paused = true;					break;			}		}				private function _move():void 		{			switch(_movementDirection)			{				case LEFT:					if (xVel > -maxVel) xVel-=2;					break;				case RIGHT:					if (xVel < maxVel) xVel+=2;					break;				case STILL:					if (xVel < 0) xVel+=2;					else if (xVel > 0) xVel-=2;					break;			}			this.rotation = -xVel;			x += xVel;		}				public function get moveable():Boolean { return this._moveable; }		public function set moveable(newMoveable:Boolean) { this._moveable = newMoveable; }		public function set position(newPos:Point):void		{			this.x = newPos.x;			this.y = newPos.y;		}		public function get position():Point { return new Point(this.x, this.y); }	}}
package com.gamejam.display {	// Flash imports	import com.gamejam.models.GameModel;	import com.gamejam.utils.map;	import com.gamejam.utils.normalise;	import flash.geom.Point;	import flash.display.MovieClip;	import flash.display.Stage;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import com.gamejam.views.GameView;	import com.gamejam.managers.SoundManager;			/**	 * Player class - movement controlled by keyboard, stores values for temperature and movement	 * @author Kev Adsett	 */	public class Player extends MovieClip	{		//player states		private var birth : int = -1;				private var _states : Array;		private var _state : int;				private var _movementDirection : int;		private var _moveable:Boolean = true;		private static var LEFT : int = -1;		private static var STILL : int = 0;		private static var RIGHT : int = 1;				private var xVel : Number = 0.0;		private var xPos : Number = 0.0;		private var maxVel : Number = 20.0;				private var health : int = 2;		private var maxHealth : int = 2;				private var temperature : int = 0;				public function Player() 		{			super();			_init();		}				private function _init():void 		{			_states = new Array(7);			//trace("Player::_init");						var totalRange = GameModel.timeForPlayerToDie * 2;			var timePerState = totalRange / 6;			trace("timePerState: " + timePerState);			var roundingBuffer = 0.1;			for (var i = -GameModel.timeForPlayerToDie; i < GameModel.timeForPlayerToDie + roundingBuffer; i += timePerState)			{				var mappedIndex = Math.ceil(map(i, -GameModel.timeForPlayerToDie, GameModel.timeForPlayerToDie+roundingBuffer, 0, 6));				_states[mappedIndex] = Math.round(i);			}			trace("_states: " + _states);						var _stage : Stage = GameView.getInstance().stage;			this._changeState();						_stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyboardDown);			_stage.addEventListener(KeyboardEvent.KEY_UP, onKeyboardUp);			this.addEventListener(Event.ENTER_FRAME, onEnterFrame);		}				private function onEnterFrame(e:Event):void 		{			if(this._moveable) _move();		}				private function onKeyboardDown(e:KeyboardEvent):void 		{			//trace("e.keyCode: " + e.keyCode);			if (e.keyCode == Keyboard.LEFT)			{				_movementDirection = LEFT;			}			else if (e.keyCode == Keyboard.RIGHT)			{				_movementDirection = RIGHT;			}		}				private function onKeyboardUp(e:KeyboardEvent):void 		{			_movementDirection = STILL;		}				public function kill():void		{			trace("Player.kill");						/*			1. Play death animation			2. (at the end of the animation) remove eventlisteners & destroy movieclip			3. Respawn at top of screen(?)			*/		}				public function increaseTemperature():void		{			temperature++;			this._changeState();		}				public function decreaseTemperature():void		{			temperature--;			this._changeState();		}				private function _changeState(): void		{			//trace("_changeState()");						var sm:SoundManager = SoundManager.getInstance();						if (temperature < _states[0]) temperature = _states[0];						if (temperature > _states[6]) temperature = _states[6];						var state:String = "";						switch(temperature)			{				case _states[0]: 					sm.playEffect(new Frozen());					this.moveable = false;					GameView.getInstance().camera.paused = true;					state = this.getStateAsString(temperature);					break;				case _states[1]:					sm.playEffect(new Freeze());					state = this.getStateAsString(temperature);					break;				case _states[2]:					sm.playEffect(new Freeze());					state = this.getStateAsString(temperature);					break;				case _states[3]:					sm.playEffect(new Droplet1());					state = this.getStateAsString(temperature);					break;				case _states[4]:					sm.playEffect(new Boil());					state = this.getStateAsString(temperature);					break;				case _states[5]:					sm.playEffect(new Boil());					state = this.getStateAsString(temperature);					break;				case _states[6]:					sm.playEffect(new Boiled());					this.moveable = false;					GameView.getInstance().camera.paused = true;					state = this.getStateAsString(temperature);					break;			}			// play the relevant animation			if (state != "") this.gotoAndPlay(state);				// update the temp gauge			GameView.getInstance().tempGauge.update(temperature);		}				private function _move():void 		{			switch(_movementDirection)			{				case LEFT:					if (xVel > -maxVel) xVel-=2;					break;				case RIGHT:					if (xVel < maxVel) xVel+=2;					break;				case STILL:					if (xVel < 0) xVel+=2;					else if (xVel > 0) xVel-=2;					break;			}			this.rotation = -xVel;			x += xVel;		}				public function getStateAsString(numericState: Number):String		{			switch(numericState)			{				case _states[0]: 					return "frozen";				case _states[1]:					return "freezing2";				case _states[2]:					return "freezing1";				case _states[3]:					return "water";				case _states[4]:					return "boiling1";				case _states[5]:					return "boiling2";				case _states[6]:					return "boiled";				default:					trace("Player.getStateAsString: Unknown state: " + numericState);					return "";			}		}				public function get moveable():Boolean { return this._moveable; }		public function set moveable(newMoveable:Boolean) { this._moveable = newMoveable; }		public function set position(newPos:Point):void		{			this.x = newPos.x;			this.y = newPos.y;		}		public function get position():Point { return new Point(this.x, this.y); }	}}